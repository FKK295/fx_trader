# テスト戦略

このドキュメントでは、FX Trader アプリケーションのテスト戦略について説明します。

## テストの種類

### 1. ユニットテスト

- **目的**: 個々の関数やメソッドが期待通りに動作することを確認
- **範囲**: 単一の関数やクラス
- **実行頻度**: コミットごと、プルリクエストごと
- **実行時間**: 高速（数秒〜1分）
- **ツール**: `pytest`, `unittest.mock`

### 2. 統合テスト

- **目的**: 複数のコンポーネントが連携して正しく動作することを確認
- **範囲**: 複数のモジュールやサービス間の統合
- **実行頻度**: プルリクエストごと、マージ前に
- **実行時間**: 中程度（1〜5分）
- **ツール**: `pytest`, `docker-compose`

### 3. E2E（エンドツーエンド）テスト

- **目的**: ユーザーストーリー全体が期待通りに動作することを確認
- **範囲**: フロントエンドからバックエンド、データベースまで含めた全体
- **実行頻度**: デイリービルド、リリース前
- **実行時間**: 長い（5分以上）
- **ツール**: `Playwright`, `Selenium`

### 4. パフォーマンステスト

- **目的**: システムのパフォーマンス要件を満たしているか確認
- **範囲**: 重要なAPIエンドポイント、バッチ処理
- **実行頻度**: リリース前、定期的な監視
- **ツール**: `locust`, `k6`

## テストカバレッジ

- 目標カバレッジ: 80%以上
- 重要なビジネスロジック: 100%カバレッジを目標
- ビューやテンプレート: 主要なフローのみカバー

## テストデータ管理

### フィクスチャ

- テスト用のデータはフィクスチャとして管理
- データベースの状態は各テストケースの前後でリセット
- 機密情報は含めない

### モックとスタブ

- 外部API呼び出しはモック化
- データベース接続はテスト用のインメモリデータベースを使用
- 時間に依存する処理はモック化

## CI/CDパイプライン

### プルリクエスト時

1. コードフォーマットチェック (`black`, `isort`)
2. リンター実行 (`flake8`, `mypy`)
3. セキュリティチェック (`bandit`, `safety`)
4. ユニットテスト実行
5. カバレッジレポート生成

### マージ時

1. 統合テストの実行
2. E2Eテストの実行
3. カバレッジ閾値の確認
4. ドキュメントのビルド

## テストの書き方ガイド

### テストの構造

```python
def test_functionality():
    # 1. テストの準備 (Arrange)
    test_data = create_test_data()
    
    # 2. テスト対象の実行 (Act)
    result = function_under_test(test_data)
    
    # 3. 結果の検証 (Assert)
    assert result.expected == result.actual
    
    # 4. 後片付け (必要な場合)
    cleanup_test_data()
```

### ベストプラクティス

1. **テストは独立させる**
   - テストケース間で状態を共有しない
   - 各テストは独立して実行可能にする

2. **説明的なテスト名**
   - テスト対象のメソッド名と期待する動作を記述
   - 例: `test_create_order_with_valid_data_should_succeed`

3. **アサーションメッセージ**
   - アサーションには説明的なメッセージを付与
   - 例: `assert result.status == 'success', f"Expected success but got {result.status}"`

4. **テストデータの準備**
   - テストデータはフィクスチャやファクトリで管理
   - テストケースごとに必要なデータのみをセットアップ

5. **エッジケースのテスト**
   - 境界値分析を行う
   - エラーパスを網羅する

## パフォーマンステスト

### テストシナリオ

1. **負荷テスト**
   - 通常の負荷での応答時間
   - ピーク時のパフォーマンス

2. **耐久テスト**
   - 長時間稼働時のメモリリークの有無
   - 接続プールの管理

3. **スケーラビリティテスト**
   - 水平スケーリング時のパフォーマンス
   - データベースのシャーディング

## セキュリティテスト

### テスト項目

1. **認証・認可**
   - ロールベースのアクセス制御
   - トークンの有効期限と更新

2. **入力検証**
   - SQLインジェクション
   - XSS（クロスサイトスクリプティング）
   - CSRF（クロスサイトリクエストフォージェリ）

3. **データ保護**
   - 機密情報のマスキング
   - 適切な暗号化の適用

## テスト環境

### ローカル環境

- 開発者が個々のマシンで実行
- Docker Compose を使用した依存関係の管理

### CI環境

- GitHub Actions を使用した自動テスト
- プルリクエストごとにテストを実行

### ステージング環境

- 本番環境と同等の構成
- E2Eテストの実行に使用

## メトリクスとモニタリング

### 収集するメトリクス

- テストの実行時間
- カバレッジ率
- パフォーマンスメトリクス（応答時間、スループット）
- エラー率

### アラート

- テストの失敗
- パフォーマンスの劣化
- カバレッジの低下

## テストのメンテナンス

### テストのリファクタリング

- 重複したコードを共通化
- テストヘルパー関数の作成
- テストデータファクトリの活用

### フラッキーテストの対処

- テストの並列実行時の競合を防ぐ
- タイミングに依存するテストの安定化
- リトライメカニズムの導入

## 参考資料

- [pytest ドキュメント](https://docs.pytest.org/)
- [Testing FastAPI](https://fastapi.tiangolo.com/tutorial/testing/)
- [Test-Driven Development with Python](https://www.obeythetestinggoat.com/)
